<!DOCTYPE html><html amp=""><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# website: http://ogp.me/ns/websaite#">
        <meta charset="utf-8">
        <script async="" src="https://cdn.ampproject.org/v0.js"></script>
        <script async="" custom-element="amp-analytics" src="https://cdn.ampproject.org/v0/amp-analytics-0.1.js"></script>
        <script async="" custom-element="amp-youtube" src="https://cdn.ampproject.org/v0/amp-youtube-0.1.js"></script>
        <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
        <meta property="og:type" content="article">
        <meta property="og:url" content="https://amp.kbys.tk/5f21236bb4dbec001ee52cbf.html">
        <meta property="og:title" content="nwtgck: Webブラウザ上で純粋なHTTPだけで単方向リアルタイム通信を可能にするHTTPのストリーミングアップロードが遂にやってくる | I am Electrical machine">
        <meta property="og:site_name" content="I am Electrical machine">
        
                <meta name="twitter:card" content="summary_large_image">
              
        
                <meta property="og:image" content="https://gyazo.com/37a9d37fee6aa495f17bbe83857d913e/raw">
              
        <style amp-boilerplate="">
          body {
            -webkit-animation: -amp-start 8s steps(1, end) 0s 1 normal both;
            -moz-animation: -amp-start 8s steps(1, end) 0s 1 normal both;
            -ms-animation: -amp-start 8s steps(1, end) 0s 1 normal both;
            animation: -amp-start 8s steps(1, end) 0s 1 normal both;
          }
          @-webkit-keyframes -amp-start {
            from {
              visibility: hidden;
            }
            to {
              visibility: visible;
            }
          }
          @-moz-keyframes -amp-start {
            from {
              visibility: hidden;
            }
            to {
              visibility: visible;
            }
          }
          @-ms-keyframes -amp-start {
            from {
              visibility: hidden;
            }
            to {
              visibility: visible;
            }
          }
          @-o-keyframes -amp-start {
            from {
              visibility: hidden;
            }
            to {
              visibility: visible;
            }
          }
          @keyframes -amp-start {
            from {
              visibility: hidden;
            }
            to {
              visibility: visible;
            }
          }
        </style>
        <noscript>
          <style amp-boilerplate>
            body {
              -webkit-animation: none;
              -moz-animation: none;
              -ms-animation: none;
              animation: none;
            }
          </style>
        </noscript>
        <style amp-custom="">
          a {
  color: #0469ea;
  text-decoration: none;
}
amp-img.contain img {
  object-fit: contain;
}
blockquote {
  margin: 0;
  border-left: solid 4px #a0a0a0;
  padding-left: 4px;
  background-color: rgba(128,128,128,0.1);
}
body {
  font-family: "Roboto",Helvetica,Arial,"Hiragino Sans",sans-serif;
}
.container-0-0-1 {
  padding: 1rem;
}
@media (min-width: 640px) {
  .container-0-0-1 {
    margin: 0 auto;
    max-width: 640px;
  }
}
.logo-0-0-2 {
  display: flex;
  margin-bottom: .5rem;
  justify-content: center;
}
.imgContainer-0-0-3 {
  width: 100%;
  height: 30vh;
  position: relative;
}
.sbLink-0-0-4 {
  font-size: .7rem;
  text-align: center;
}
.sbLink-0-0-4 a {
  color: rgba(0, 0, 0, 0.7);
  text-decoration: none;
}
.level-0-0-5 {
  font-weight: bold;
}
.level-2-0-0-6 {
  font-size: 1.2em;
  line-height: 28px;
}
.level-3-0-0-7 {
  font-size: 1.44em;
  line-height: 35px;
}
.level-4-0-0-8 {
  font-size: 1.73em;
  line-height: 42px;
}
.level-5-0-0-9 {
  font-size: 2.07em;
  line-height: 49px;
}
.level-6-0-0-10 {
  font-size: 2.49em;
  line-height: 56px;
}
.level-7-0-0-11 {
  font-size: 3em;
  line-height: 63px;
}
.level-8-0-0-12 {
  font-size: 3.58em;
  line-height: 77px;
}
.level-9-0-0-13 {
  font-size: 4.3em;
  line-height: 91px;
}
.level-10-0-0-14 {
  font-size: 5.16em;
  line-height: 105px;
}
.unlinked-0-0-15 {
  color: #004bad;
}
.moreProfile-0-0-16 {
  margin: 2rem 0;
  text-align: center;
}
.moreProfile-0-0-16 a {
  color: #fff;
  padding: 1rem;
  background: linear-gradient(0deg, rgba(120,119,119,1) 0%, rgba(5,119,254,1) 100%);
  font-weight: bold;
  text-shadow: 0px 1px 2px #333;
  border-radius: 2rem;
}
.donation-0-0-17 {
  margin-top: 2rem;
  text-align: center;
}
.donation-0-0-17 a {
  color: #fff;
  padding: 1rem;
  background: linear-gradient(0deg, rgba(255,177,8,1) 0%, rgba(235,251,26,1) 100%);
  font-weight: bold;
  text-shadow: 0px 1px 2px #333;
  border-radius: 2rem;
}
        </style>
        <title>nwtgck: Webブラウザ上で純粋なHTTPだけで単方向リアルタイム通信を可能にするHTTPのストリーミングアップロードが遂にやってくる | I am Electrical machine</title>
        <link rel="canonical" href="https://scrapbox.io/jigsaw/nwtgck: Webブラウザ上で純粋なHTTPだけで単方向リアルタイム通信を可能にするHTTPのストリーミングアップロードが遂にやってくる">
      </head>
      <body>
        <amp-analytics type="gtag" data-credentials="include">
          <script type="application/json">
            {
              "vars": {
                "gtag_id": "UA-96527600-2",
                "config": {
                  "UA-96527600-2": { "groups": "default" }
                }
              },
              "triggers": {
                "trackPageView": {
                  "on": "visible",
                  "request": "pageview"
                }
              }
            }
          </script>
        </amp-analytics>
        <div class="container-0-0-1">
          <div class="logo-0-0-2">
            <a href="https://amp.kbys.tk">
              <amp-img src="https://i.gyazo.com/67ba2e0bfe934bd265f24e4c3cbd85a4.jpg" width="40px" height="40px"></amp-img>
            </a>
          </div>
          <div class="sbLink-0-0-4">
            <a href="https://scrapbox.io/jigsaw/nwtgck: Webブラウザ上で純粋なHTTPだけで単方向リアルタイム通信を可能にするHTTPのストリーミングアップロードが遂にやってくる">
              スクボで読む
            </a>
          </div>
          <h1>nwtgck: Webブラウザ上で純粋なHTTPだけで単方向リアルタイム通信を可能にするHTTPのストリーミングアップロードが遂にやってくる</h1>
          <div>
            
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          Web標準のHTTPクライアント
        <code>fetch()</code>
      でストリーミングしながらアップロードできるようになる。
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          数行で画面共有したり、世界一シンプルかもしれないテキストチャットなども紹介したい。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <div class="imgContainer-0-0-3">
          <amp-img class="contain" layout="fill" src="https://gyazo.com/37a9d37fee6aa495f17bbe83857d913e/thumb/1000">
        </amp-img></div>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          なぜHTTPでのストリーミングアップロード？
        </span>
      
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          巨大なデータの暗号化・圧縮
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          終わりが決まっていない無限のデータ
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          などをサーバーにアップロードすることがある。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          今までも
        <code>&lt;input type="file"&gt;</code>
      から取得したFile（Blob）が巨大でも純粋なHTTPで送信できていた。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          だが、このファイルを圧縮したりクライアントサイドで暗号化しようとすると
        <span class="level-0-0-5 ">
          全部メモリ上に展開する必要
        </span>
      がある。そのため巨大なファイルの圧縮や暗号化したものを単一のHTTPリクエストで送信することが不可能だった。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          任意のストリームをエンドツーエンド暗号化（E2E暗号化）をすることも可能になる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          終わりが分からない
        <span class="level-0-0-5 ">
          無限のデータに関しても単一のHTTPリクエストで送信することは今まで不可能
        </span>
      だった。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          例えば「終わりが分からない」というのはブラウザ上で録画・録音しながらリアルタイムにWebサーバーに送信し続けるレコーダーなどが考えられる。こういった場合はWebSocketやWebRTCなどのWebの技術を使う選択肢になると思う。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          そして最も重要なのは
        <span class="level-0-0-5 ">
          これらは組み合わせることができる
        </span>
      こと。例えば録画・録音しながら圧縮しつつ暗号化してリアルタイムに送信することができる。
        <span class="level-0-0-5 ">
          ストリームは時間的にも空間的に効率の良い技術
        </span>
      。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-2-0-0-6">
          なぜHTTPか？
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          HTTPはとてもシンプル。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          いざとなればncコマンドやtelnetコマンドなどで手で書くこともできる（HTTP/1.1）。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          HTTPは非常に多くの場所で使われている。iOS標準のShortchutアプリやMicrosoft Flowなどの自動化アプリやスマート家電の通信やDocker（/var/run/docker.sock ）などWebブラウザに限らずHTTPは使われている。そのいう点でHTTPは他のデバイスやソフトウェアと連携しやすいインターフェースだと考えてる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          HTTP/1.1は成熟して枯れた技術で、
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          TCPを使いつつもパフォーマンスが向上したHTTP/2や
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          UDP上で設計されたQUICを使うHTTP/3など
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          HTTPは新しい技術がとりまれてこれからも互換性を保ちつつ発展している。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          パフォーマンスだけではなく、HTTP/3が利用しているQUICには「コネクションマイグレーション」といったIPアドレスが変わっても接続し続けるような機能などもあるらしい。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          そしてWebブラウザは多くのデバイスにすでにインストールされている。このWebブラウザでHTTPのボディをストリーミングしてアップロードする機能が搭載されることでさまざな用途での可能性が広がる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          どういう機能なのか？
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 ">
          ひとことでいうと、以下ができるようになった
        </span>
      。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>fetch(myUrl, {
  method: 'POST',
  body: &lt;ここにReadableStream&gt;
})</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          仕様: 
            <a href="https://fetch.spec.whatwg.org/#concept-body-stream" target="_blank" rel="noopener">
              https://fetch.spec.whatwg.org/#concept-body-stream
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          fetchの
        <code>body: </code>
      のところに
        <code>ReadableStream</code>
      が使えるようになる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          いままで調べた限りXMLHttpRequestにもストリーミングアップロードの機能はなかった。つまりPolyfillも不可能だった。WebSocketを使うなど素のHTTPではない方法でサーバーサイドでどうにかするしかなかった。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-2-0-0-6">
          fetch()
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <code>fetch()</code>
      は
        <span class="level-0-0-5 ">
          ブラウザ標準で使えるHTTPのリクエストをするクライアント
        </span>
      。HTTPクライアントだとaxiosは人気のようだが
        <code>fetch()</code>
      は外部のライブラリ使用せず最初から使えるWeb標準の関数（広まって欲しい）。また
        <code>XMLHttpRequest</code>
      よりもモダンなAPIになっている。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-2-0-0-6">
          ReadableStream
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 ">
          ブラウザで使えるストリーム
        </span>
      。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          例えば以下で無限の乱数バイト列を出し続けるストリームが作れる。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>// 無限の乱数バイト列
new ReadableStream({
  pull(ctrl) {
    ctrl.enqueue(window.crypto.getRandomValues(new Uint32Array(128)));
  }
})</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          身近なところでは
        <code>(await fetch(...)).body</code>
      の型がReadableStreamになっている（HTTPレスポンスのボディ）。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          主要ブラウザベンダーの関心
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          この
        <code>fetch()</code>
      のストリーミングアップロードに関して主要なブラウザが関心があるかどうか。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下を見ると、Firefox、
              <a href="https://amp.kbys.tk/5d73e6aed8c364001792515c">Safari</a>
            でも実装されそう。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <div class="imgContainer-0-0-3">
          <amp-img class="contain" layout="fill" src="https://gyazo.com/aa7d3bba8a99e677573925bccfc2175a/thumb/1000">
        </amp-img></div>
      
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          
            <a href="https://github.com/whatwg/fetch/pull/425" target="_blank" rel="noopener">
              Uploading a Request made from a ReadableStream body by yutakahirano · Pull Request #425 · whatwg/fetch
            </a>
          
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          
            <a href="https://docs.google.com/document/d/1q090ovJ4gd8wSfVtvuoZLMZ51YkiFDsEZ0Jiqi41Iys/edit#heading=h.85gziabhajhg" target="_blank" rel="noopener">
              Service Worker WG TPAC 2019 - Google Docs
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          MDNでの記述
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下のようにMDNでも
        <code>body</code>
      に
        <code>ReadableStream</code>
      が使えるようにだいぶ前から書かれていた。だが調べた限りそれを実装しているメジャーなブラウザは一つもなかった（
            <a href="https://github.com/whatwg/fetch/pull/425#issuecomment-462634914" target="_blank" rel="noopener">
              https://github.com/whatwg/fetch/pull/425#issuecomment-462634914
            </a>
          ）。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <div class="imgContainer-0-0-3">
          <amp-img class="contain" layout="fill" src="https://gyazo.com/594dbd91d89f84e471f876d264ccc4d8/thumb/1000">
        </amp-img></div>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" target="_blank" rel="noopener">
              WindowOrWorkerGlobalScope.fetch() - Web APIs | MDN
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          Google Chromeで実際に使う
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          現在Google ChromeのBetaまで使えるようになっている。（Version 85.0.4183.38 (Official Build) beta (64-bit)で確認）
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          Chrome Betaのインストール: 
            <a href="https://www.google.co.jp/chrome/beta/" target="_blank" rel="noopener">
              Google Chrome Beta - Google Chrome
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          使用するには、
        <code>chrome://flags/</code>
      にアクセスして以下の「Experimental Web Platform features」をEnabledにする必要がある（トークンを使う方法もある）。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <div class="imgContainer-0-0-3">
          <amp-img class="contain" layout="fill" src="https://gyazo.com/561cca07e57978fbc8e5b816111dc672/thumb/1000">
        </amp-img></div>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
            <a href="https://web.dev/fetch-upload-streaming/#enable-flags" target="_blank" rel="noopener">
              Streaming requests with the fetch API
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          テキストチャットを作る
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          もしかすると世界一シンプルかもしれないブラウザでできる簡易テキストチャット。日本語や絵文字送れる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          左側が送る人、右側が受け取る人。もう1組作れば右側から送ることもできる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下がコード。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <code>&lt;input&gt;</code>
      の入力をReadableStreamにして、それをfetch()でPOSTするだけ。標準ライブラリのみで実現。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>const readableStream = new ReadableStream({
  start(ctrl) {
    const encoder = new TextEncoder();
    window.myinput.onkeyup = (ev) =&gt; {
      if (ev.key === 'Enter') {
        ctrl.enqueue(encoder.encode(ev.target.value+'\n'));
        ev.target.value = '';
      }
    }
  }
});

fetch("https://ppng.io/mytext", {
  method: 'POST',
  body: readableStream,
  headers: { 'Content-Type': 'text/plain;charset=UTF-8' },
  allowHTTP1ForStreamingUpload: true,
});</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          フル: 
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/text_stream.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/text_stream.html
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <code>allowHTTP1ForStreamingUpload: true</code>
      はGoogle Chromeの一時的なプロパティ。これはHTTP/1.1でもこの機能を利用するため。（https://github.com/chromium/chromium/commit/4c75c0c9f730589ad8d6c33af919d6b105be1462#diff-0f684d35848d8674d6bd9c5673588856）
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          POST先の
            <a href="https://ppng.io/" target="_blank" rel="noopener">
              https://ppng.io/
            </a>
          はPiping Serverというサーバーになっている。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          Piping Serverを使うと
        <code>POST /hogehoge</code>
      したデータが
        <code>GET /hogehoge</code>
      で取得できる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          そのため上記のデモのように、受信側のクライアントはただ
        <code>https://ppng.io/mytext</code>
      をブラウザ開いているだけ。受信側のコードを書く必要はなかった。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          自前でPiping Serverを立てて検証したいときはDockerがあれば
        <code>docker run -p 8181:8080 nwtgck/piping-server</code>
      で出来る。その他の方法：「Piping Serverを自前でホストする方法をいくつか」
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          上記のコードは
        <code>readableStream.pipeThrough(new TextEncoderStream())</code>
      を使うとよりストリームを使っている感じになる。（フル: 
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/text_stream_with_text_encoder_stream.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/text_stream_with_text_encoder_stream.html
            </a>
          ）
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          画面共有を作る
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下のように画面がvideo_player.htmlを開いているブラウザに共有できている。これも標準ライブラリのみを使っている。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下が画面を送りたい側のコード。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下のほとんどはMediaStreamをReadableStreamに変換するコードが占めている。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>(async () =&gt; {
  // Get display
  const mediaStream = await navigator.mediaDevices.getDisplayMedia({video: true});
  // Convert MediaStream to ReadableStream
  const readableStream = mediaStreamToReadableStream(mediaStream, 100);

  fetch("https://ppng.io/myvideo", {
    method: 'POST',
    body: readableStream,
    allowHTTP1ForStreamingUpload: true,
  });
})();

// Convert MediaStream to ReadableStream
function mediaStreamToReadableStream(mediaStream, timeslice) {
  return new ReadableStream({
    start(ctrl){
      const recorder = new MediaRecorder(mediaStream);
      recorder.ondataavailable = async (e) =&gt; {
        ctrl.enqueue(new Uint8Array(await e.data.arrayBuffer()));
      };
      recorder.start(timeslice);
    }
  });
}</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          上記でやっていることは、
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          
        <code>navigator.mediaDevices.getDisplayMedia({video: true})</code>
      で画面の映像のMediaStreamを手に入れる。
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          そのMediaStreamをReadableStreamに変換してfetch()でPOSTする。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下は画面を見る側のコード。videoタグのみ。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>html</code>
          <pre><code>&lt;video src="https://ppng.io/myvideo" autoplay muted&gt;&lt;/video&gt;</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          さっきのテキストチャットと同様にPiping Serverを使っている。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          つまり
        <code>POST /myvideo</code>
      しているので
        <code>/myvideo</code>
      をvideoタグで指定すれば画面を見ることができる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-2-0-0-6">
          コマンドラインとの高い親和性
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          上記はvideoタグで閲覧した。その代わりにffplayを使えばコマンドライン上で閲覧することができる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下のデモのようにcurlコマンドとffplayコマンドだけで、画面共有ができる。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>bash</code>
          <pre><code>curl https://ppng.io/myvideo | ffplay -</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
              <amp-youtube data-videoid="oORveGAFrt0" layout="responsive" width="480" height="270"></amp-youtube>
            
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          fetch()でReadableStreamがPOSTできるようになって、WebブラウザからのPOSTを受信して表示することも、コマンドラインから画面共有してブラウザ表示することでもできるようになった。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          関連：「Piping Serverとffmpegで画面共有」
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 ">
          今までcurlでできていたことがWebブラウザでもできるようになり、互換性・対称性が高まった
        </span>
      と思う。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          音声通話・ビデオ通話などなど
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          Webブラウザ標準で音声やinカメラなどからのMediaStreamを取得できる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          嬉しいことに、多くのモバイルでのブラウザでも対応している。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
            <a href="https://developer.mozilla.org/ja/docs/Web/API/MediaDevices/getUserMedia" target="_blank" rel="noopener">
              https://developer.mozilla.org/ja/docs/Web/API/MediaDevices/getUserMedia
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          そのため、上記の
        <code>const mediaStream = </code>
      を変えるだけで同じコードで画面共有以外にも音声通話・ビデオ通話することもできる。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>// 音声
navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true } })</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>// ビデオ + 音声
navigator.mediaDevices.getUserMedia({ video: true, audio: { echoCancellation: true } })</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下がコード。
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          音声通話: 
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/simple_phone.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/simple_phone.html
            </a>
          
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          ビデオ通話: 
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/video_chat.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/video_chat.html
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          映像にフィルタをつける
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
              <amp-youtube data-videoid="VcKJR8D8IFA" layout="responsive" width="480" height="270"></amp-youtube>
            
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          HTMLのcanvasからも
        <code>.captureStream()</code>
      でMediaStreamを取得できる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下の関数はインメモリでvideoやcanvasを作って引数のMediaStreamを加工してMediaStreamを返す。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          セピア調にするためにJSManipulateというライブラリを利用した。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>// ...略...

// セピア調にするフィルタ
async function sepiaMediaStream(mediaStream) {
  const memVideo = document.createElement('video');
  memVideo.srcObject = mediaStream;
  await memVideo.play();

  const width = memVideo.videoWidth;
  const height = memVideo.videoHeight;
  const srcCanvas = document.createElement('canvas');
  const dstCanvas = document.createElement('canvas');
  srcCanvas.width = dstCanvas.width = width;
  srcCanvas.height = dstCanvas.height = height;
  const srcCtx = srcCanvas.getContext('2d');
  const dstCtx = dstCanvas.getContext('2d');

  (function loop(){
    srcCtx.drawImage(memVideo, 0, 0, width, height);
    const frame = srcCtx.getImageData(0, 0, width, height);

    JSManipulate.sepia.filter(frame);
    dstCtx.putImageData(frame, 0, 0);
    setTimeout(loop, 0);
  })();

  return dstCanvas.captureStream();
}</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          フル: 
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/screen_share_with_filter.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/screen_share_with_filter.html
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-2-0-0-6">
          canvasの可能性
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          可能性として、カメラからのMediaStreamを加工すれば、SnowやSnap CameraのようなフィルタをWebのクライアントサイドで作ることもできるはず。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          またcanvasは色々できる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          WebGLもcanvasで描画する。
            <a href="https://threejs.org/" target="_blank" rel="noopener">
              three.js – JavaScript 3D library
            </a>
          を見るとcanvasの可能性を感じると思う。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          個人的には
            <a href="https://demos.littleworkshop.fr/infinitown" target="_blank" rel="noopener">
              Infinitown | A WebGL Experiment by Little Workshop
            </a>
          が好き。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          WebでARやVRを実現するWebXRでもcanvasを使われている。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          これらcanvasに描画したものをMediaStreamで取得してリアルタイムで送信できる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          エンドーツーエンド暗号化で画面共有
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          エンドツーエンド（E2E暗号化）をして画面共有する。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          E2E暗号化することでサーバーを信用しなくても安全に通信ができる。そしてこれはクライアントサイドで暗号化することが必須。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
              <amp-youtube data-videoid="lxpxeB_0UDk" layout="responsive" width="480" height="270"></amp-youtube>
            
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          暗号化にはOpenPGP.jsを利用している。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下の関数で任意のreadableStreamをpasswordで暗号化できる。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>// Encrypt ReadableStream with password by OpenPGP
async function encryptStream(readableStream, password) {
  const options = {
    message: openpgp.message.fromBinary(readableStream),
    passwords: [password],
    armor: false
  };
  const ciphertext = await openpgp.encrypt(options);
  return ciphertext.message.packets.write();
}</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          映像を見る側がPWAなどで使われるService Workerを利用している。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          目的は
        <code>https://localhost:8080/e2ee_screen_share/swvideo#myvideo"</code>
      と指定すると復号された動画がHTTPでGETすること。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          実際のコードは以下にある。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/tree/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/e2ee_screen_share" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/tree/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/e2ee_screen_share
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          （「ファイルのストリーミング強制保存をクロスオリジンでも実現させるService Workerの裏技ぽい使い方」も似たようなService Workerの使い方）
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          WebブラウザにはWeb Cryptoがある。これに安全な鍵生成やディフィー・ヘルマン鍵共有をするなども可能。（詳細：Web Cryptoで楕円曲線ディフィー・ヘルマン鍵共有して、暗号化 &amp; 復号）
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          画面共有に限らず今まで紹介した例やこれからの例のすべてでこのE2E暗号化と組み合わせることができる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          つまりE2E暗号化で画面共有・音声通話・ビデオ通話・チャット・ファイル転送などなどできる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          いままでの
        <code>fetch()</code>
      ではクライアントサイドで暗号化するときはデータをすべてメモリ上に展開する必要があった。だが今回のfetch()の機能によりストリームの暗号化ができるようになりWebブラウザでのE2E暗号化での可能性が広がった。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          圧縮
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          Chromeでは
        <code>readableStream.pipeThrough(new CompressionStream('gzip'))</code>
      とすればgzipの圧縮もできる。以下はコード例。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>const readableStream = new ReadableStream({
  pull(ctrl) {
    // random bytes
    ctrl.enqueue(window.crypto.getRandomValues(new Uint32Array(128)));
  }
}).pipeThrough(new CompressionStream('gzip'))

fetch("https://ppng.io/mytext", {
  method: 'POST',
  body: readableStream,
  allowHTTP1ForStreamingUpload: true,
});</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/gzip_inifinite_stream.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/gzip_inifinite_stream.html
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          無限にランダムなバイト列を圧縮したバイト列を送信している。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          ReadableStreamから得たバイト列を圧縮する実装をすればgzipに限らず色々な圧縮ができると思う。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          暗号化や可逆圧縮に限らず、巨大な動画のクライアントサイドでエンコードをしながらアップロードしたりなどもできるはず。ffmpegをEmscriptenでブラウザで動くようにするプロジェクトはある。そういうプロジェクトでReadableStreamな動画がエンコード出来れば実現可能だろう。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          HTTPのアップロードの読み取りの進捗
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <div class="imgContainer-0-0-3">
          <amp-img class="contain" layout="fill" src="https://gyazo.com/24d9ddd32f147e0fe681d807a2bc1734/thumb/1000">
        </amp-img></div>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          XMLHTTPRequestにできてfetchにできないことの一つにアップロードの進捗を知る機能がある。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          それをReadableStreamがアップロードできることで"多少"可能にすることができるようになった。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下のようにchunk.byteLengthを数えるやりかた。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>// 進捗付きにする
const readableStreamWithProgress = readableStream.pipeThrough(progressStream(loaded =&gt; {
  const progress = window.progress_bar.value = loaded / file.size * 100;
  window.message.innerText = `${loaded} bytes (${progress.toFixed(2)}%)`;
}));

// ...省略...

function progressStream(callback) {
  let loaded = 0;
  callback(loaded);
  return new TransformStream({
    transform(chunk, ctrl) {
      ctrl.enqueue(chunk);
      loaded += chunk.byteLength;
      callback(loaded);
    }
  });
}</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          フル: 
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/file_upload_progress_with_transformstream.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/file_upload_progress_with_transformstream.html
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          注意点は、あくまでも読み取ったバイト数であり、アップロード済みのバイト数ではないこと。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          同じことを
        <code>TransformStream</code>
      ではなく
        <code>ReadableStream</code>
      を使った実装例: 
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/file_upload_progress.html" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls/blob/a107dd1fb1bbee9991a9278b10d9eaf88b52c395/file_upload_progress.html
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          fetch()がReadableStreamをアップロードできるかの判定
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          以下のようにしてこの機能に対応しているブラウザかどうか判定できる。
        </div>
      
        <div style="padding-left:0rem; overflow: scroll;">
          <code>js</code>
          <pre><code>const supportsRequestStreams = !new Request('', {
  body: new ReadableStream(),
  method: 'POST',
}).headers.has('Content-Type');</code></pre>
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          引用元: 
            <a href="https://web.dev/fetch-upload-streaming/#feature-detection" target="_blank" rel="noopener">
              Streaming requests with the fetch API
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          上記はReadableStreamのアップロードに非対応だと、
        <code>"[object ReadableStream]"</code>
      がアップロードされてしまうことを利用している様子。その結果おそらく
        <code>Content-Type: text/plain ...</code>
      がつく仕様になっているのだと思う。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          任意のプロトコル
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          任意のReadableStreamを流し込める。任意のバイト列でも転送できる。つまり任意のプロトコルのバイト列を流し込むこともできる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          「
            <a href="https://qiita.com/Cryolite/items/ed8fa237dd8eab54ef2f" target="_blank" rel="noopener">
              Piping Server を介した双方向パイプによる，任意のネットワークコネクションの確立 - Qiita
            </a>
          」ではHTTPのみで任意のプロトコルをトンネリングできることが示された。実際にSSHでcurlとsocatのみでできている。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          つまり、WebブラウザサイドでSSHクライアントを実装できれば、原理上HTTPだけでSSHができるなどの可能性がある。その他にもVNCクラインとが作れれば、リモート操作などもできるかもしれない。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          現在のChromeでは双方向は制限されている
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          「
            <a href="https://web.dev/fetch-upload-streaming/#no-duplex-communication" target="_blank" rel="noopener">
              Streaming requests with the fetch API
            </a>
          」でも触れられているとおり、現在のGoogle Chrome実装では双方向には対応していない。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <code>const res = await fetch(...)</code>
      の
        <code>res.body</code>
      もReadableStreamになっている。アップロードが完了するまでPromiseがresolveせず
        <code>await</code>
      し続ける様子。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          単方向を2つを双方向を実現できるとも思う。HTTP/2であれば同じTCPソケットに複数のHTTPリクエストがまとまり、2つHTTPリクエストするのも悪くないように思う。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          まとめ
        </span>
      
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          fetch()でReadableStreamをアップロード出来るようになった。
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          ReadableStreamが使えることで、すべてをメモリ上に展開せずに済み、巨大・無限のデータを転送できる。
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          ReadableStreamは圧縮・暗号化など加工することができる。
        </div>
      
        <div style="padding-left:1rem; margin-bottom: .5rem;">
          &lt;canvas&gt;や画面や音声やカメラなどをReadableStreamにしてHTTPで転送できる。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          サンプルコードの使い方
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          このページは以下のサンプルコードをリンクした。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
            <a href="https://github.com/nwtgck/piping-server-streaming-upload-htmls" target="_blank" rel="noopener">
              https://github.com/nwtgck/piping-server-streaming-upload-htmls
            </a>
          
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          READMEにあるように、リポジトリのルートで
        <code>python3 -m http.server</code>
      などして、
            <a href="https://localhost:8000" target="_blank" rel="noopener">
              https://localhost:8000
            </a>
          にブラウザで開くことを想定している。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          また
        <code>https://ppng.io/hogehoge</code>
      のhogehogeの部分は実行するために自分用に変えるか
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          Piping Serverを自前でホストする方法をいくつかでPiping Server自体を自前で立てるのが良いと思う。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          localでHTTPSするときは「localhostの自己署名SSL証明書をブラウザに信用させてHTTPSで通信する（Mac）」などが使える。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 level-3-0-0-7">
          おまけ
        </span>
      
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          HTTP/1.1でストリミーングされるときにTransfer-Encoding: chunkedになる。つまりチャンクごとにバイト数がテキストで挿入される。以下は、それでどれぐらいデータが増えるのか調べたもの。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          HTTPのTransfer-Encoding: chunkedした時のデータの増量は0.0174%程度だった
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
        <span class="level-0-0-5 ">
          HTTPは1つのリクエストだけでも1110TB転送
        </span>
      できたりする。REST APIやWebページ閲覧のように短いHTTPリクエストだけでないHTTPの力が広まって欲しい。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          HTTPで1110TB転送できている記録（Piping Server）
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          
                <br>
              
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          いままでcurlコマンドで当たり前のようにできていたストリーミングしながらアップロードがWebブラウザでもできるようになったので嬉しい。stableでのリリースが楽しみ。
        </div>
      
        <div style="padding-left:0rem; margin-bottom: .5rem;">
          from 
            <a href="https://scrapbox.io/nwtgck/Webブラウザ上で純粋なHTTPだけで単方向リアルタイム通信を可能にするHTTPのストリーミングアップロードが遂にやってくる" target="_blank" rel="noopener">
              /nwtgck/Webブラウザ上で純粋なHTTPだけで単方向リアルタイム通信を可能にするHTTPのストリーミングアップロードが遂にやってくる
            </a>
          
        </div>
      
          </div>
          <h2>関連ページとランダムに選ばれたページ</h2>
          <ul>
            
                  <li>
                    <a href="https://amp.kbys.tk/5d73e6aed8c364001792515c.html">
                      Safari
                    </a>
                  </li>
                
                  <li>
                    <a href="https://amp.kbys.tk/5d69111bcaebee0017a9a161.html">
                      最近クリップしたページ
                    </a>
                  </li>
                
                  <li>
                    <a href="https://amp.kbys.tk/5f2202ea0891540024938d61.html">
                      20200730
                    </a>
                  </li>
                
                  <li>
                    <a href="https://amp.kbys.tk/5dc4dc530d43b40017630543.html">
                      成蹊大学法学部教授がたどり着いたドキュメント共有ツールの決定版。塩澤一洋先生が語るScrapboxの魅力
                    </a>
                  </li>
                
                  <li>
                    <a href="https://amp.kbys.tk/5db2623762f54300174a55ff.html">
                      airbnb/react-sketchapp: render React components to Sketch ⚛️💎
                    </a>
                  </li>
                
          </ul>
          <h2>筆者について</h2>
          <div>jigsaw(ジグソウ、1991年6月12日-)は日本のプログラマ、会社代表。本名は小林貴也(こばやし たかや)。主にウェブ、フロントエンド領域で活動している。カミング・スーン合同会社の代表社員。</div>
          <div class="moreProfile-0-0-16"><a href="https://amp.kbys.tk/5c29451d434bf90017d3b219.html">さらに詳しく</a></div>
          <h2>寄附について</h2>
          <div>面白かったら<a href="https://amp.kbys.tk/5dcc34d2e8364600170f07f6.html">BTC</a>や<a href="https://amp.kbys.tk/5dcc35503afcd0001731ff2c.html">ETH</a>での寄附をお待ちしております。</div>
          <div class="donation-0-0-17"><a href="https://amp.kbys.tk/5dbbc52057d9010017438a87">寄附のきろく</a></div>
        </div>
      
    
  </body></html>